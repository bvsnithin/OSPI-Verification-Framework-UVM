# OSPI-Verification-Framework-UVM
UVM-based verification framework for OSPI controller in SoC designs. 

## 1. Introduction
Serial Peripheral Interface (SPI) is a widely used synchronous serial communication protocol for short-distance, high-speed communication between a master and one or more slave devices. SPI is simple, fast, and flexible, but its data bandwidth is limited by its single-bit data path.

To overcome bandwidth limitations, SPI has evolved into wider variants such as Quad SPI (QSPI) and Octal SPI (OSPI). These variants increase throughput by transferring multiple bits per clock cycle while retaining the fundamental SPI communication model.

This project focuses on the design and verification of an OSPI controller, demonstrating how modern high-speed external memory interfaces are implemented and validated.

## 2. SPI, QSPI, and OSPI Overview

### 2.1 Serial Peripheral Interface (SPI)

SPI is a master-slave protocol consisting of four primary signals:
SCLK: Serial clock generated by the master
MOSI: Master Out, Slave In
MISO: Master In, Slave Out
CS / SS: Chip Select, used to select a slave device

Key characteristics:
One bit transferred per clock cycle
Slave selection is done using dedicated chip-select signals
No built-in addressing or arbitration
Simple hardware implementation

### 2.2 Quad SPI (QSPI)

QSPI extends SPI by increasing the number of data lines from one to four.

Key enhancements:
Uses four bidirectional data lines (IO[3:0])
Transfers four bits per clock cycle
Retains SPI-style chip-select-based slave selection
Commonly used for higher-speed flash memory access
QSPI improves bandwidth without fundamentally changing the SPI protocol.

### 2.3 Octal SPI (OSPI)

OSPI further extends the SPI concept by using eight data lines.

Key features:
Uses eight bidirectional data lines (IO[7:0])
Transfers eight bits per clock cycle
Optional DDR (Double Data Rate) operation
Optional DQS (Data Strobe) for high-speed sampling
Typically used for high-performance external flash memories

Despite its higher speed and complexity, OSPI:
Does not introduce device addressing
Continues to use chip select for device selection
Follows a command â†’ address â†’ data transaction model

## ðŸš€ How to Run the Project

### For Texas A&M Students

If you are a **Texas A&M student** with access to the ECEN Linux servers, follow these steps:

1. **Clone the repository** on the ECEN Linux server:
   ```bash
   git clone <repository-url>
   cd OSPI-Verification-Framework-UVM
   ```

2. **Load the CSCE-616 environment**:
   ```bash
   load-csce-616
   ```
   This command sets up all necessary EDA tools, compilers, and simulators for the project.

3. **Run the setup script**:
   ```bash
   bash setupX.bash
   ```
   This script configures the environment and prepares the project for simulation.

4. **Navigate to the simulation directory and run the testbench**:
   ```bash
   cd sim
   xrun -f run.f
   ```
   This command compiles and runs the complete verification environment using the xrun simulator.
